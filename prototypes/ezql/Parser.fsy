%{
open Ast
%}

%start toplevel
%start expr

%token <string> ID
%token <int> INTEGER
%token <bool> BOOLEAN
%token <string> STRING
%token LET IN WITH IF THEN ELSE FUN
%token LPAREN RPAREN LBRACKET RBRACKET LBRACE RBRACE ASSIGN
%token DOT COLON SEMICOLON ARROW PLUS MINUS TIMES DIV MOD COMMA
%token SEMICOLON2
%token GT GTE EQ DIFF LTE LT AND OR TRUE FALSE
%token SEC MIN
%token EOF
%token INT

%token ENTITY CREATE_FROM BELONGS_TO HAS_MANY MEMBER

%nonassoc LET IN
%right ARROW
%right SEMICOLON
%nonassoc IF THEN ELSE
%left OR
%left AND
%left EQ DIFF
%left GT GTE LTE LT
%left PLUS MINUS
%left TIMES DIV MOD
%left DOT
%nonassoc LPAREN LBRACKET

%type <prog list> toplevel
%type <expr> expr

%%

toplevel:   EOF                                            { [] }
          | defTop                                         { $1 }
          | entityTop                                      { $1 }
          | exprTop                                        { $1 }

defTop:   def EOF                                          { [$1] }
        | def SEMICOLON2 toplevel                          { $1::$3 }

entityTop:   entity EOF                                    { [$1] }
           | entity SEMICOLON2 toplevel                    { $1::$3 }

exprTop:   expr EOF                                        { [Expr $1] }
         | expr SEMICOLON2 toplevel                        { (Expr $1)::$3 }

def: ID ASSIGN expr                                        { Def (Identifier $1, $3) }

entity: ENTITY ID ASSIGN entityBody                        { Entity (Identifier $2, $4) }

entityBody: createFrom associations members				   { $1, $2, $3 }

createFrom: CREATE_FROM LPAREN expr COMMA symbol RPAREN    { ($3, $5) }

associations:   BELONGS_TO symbol associations             { (BelongsTo $2)::$3 }
              | HAS_MANY symbol associations               { (HasMany $2)::$3 }
              |                                            { [] }
              
members:   MEMBER ID DOT ID ASSIGN expr members            { (Member (Identifier $2, Identifier $4, $6))::$7 }
         |                                                 { [] }

expr:   expr DOT ID                                        { MemberAccess ($1, Identifier $3) }
      | expr LPAREN args RPAREN                            { match $1 with
                                                             | MemberAccess (obj, memb) -> MethodCall (obj, memb, $3)
                                                             | _ -> FuncCall ($1, $3) }
      | LPAREN expr RPAREN                                 { $2 }
      | expr LBRACKET expr RBRACKET                        { ArrayIndex ($1, $3) }
      | FUN parameters ARROW expr                          { Lambda ($2, $4) }
      | expr SEMICOLON expr                                { Seq ($1, $3) }
      | binaryExpr                                         { $1 }
      | IF expr THEN expr ELSE expr                        { If ($2, $4, $6) }
      | LET ID ASSIGN expr IN expr                         { Let (Identifier $2, $4, $6) }
      | record                                             { $1 }
      | ID                                                 { Id (Identifier $1) }
      | symbol                                             { SymbolExpr $1 }
      | INTEGER timeUnit                                   { Time (Integer $1, $2) }
      | INTEGER                                            { Integer $1 }
      | BOOLEAN                                            { Bool $1 }
      | STRING                                             { String $1 }

binaryExpr:   arith                                        { $1 }
            | conditional                                  { $1 }

arith:   expr PLUS  expr                                   { BinaryExpr (Plus, $1, $3) }
       | expr MINUS expr                                   { BinaryExpr (Minus, $1, $3) }
       | expr TIMES expr                                   { BinaryExpr (Times, $1, $3) }
       | expr DIV   expr                                   { BinaryExpr (Div, $1, $3) }
       | expr MOD   expr                                   { BinaryExpr (Mod, $1, $3) }

conditional:   expr GT   expr                              { BinaryExpr (GreaterThan, $1, $3) }
             | expr GTE  expr                              { BinaryExpr (GreaterThanOrEqual, $1, $3) }
             | expr EQ   expr                              { BinaryExpr (Equal, $1, $3) }
             | expr DIFF expr                              { BinaryExpr (NotEqual, $1, $3) }
             | expr LTE  expr                              { BinaryExpr (LessThanOrEqual, $1, $3) }
             | expr LT   expr                              { BinaryExpr (LessThan, $1, $3) }
             | expr AND  expr                              { BinaryExpr (And, $1, $3) }
             | expr OR   expr                              { BinaryExpr (Or, $1, $3) }

symbol: COLON ID                                           { Symbol $2 }

Type:   INT                                                { TyInt }
      | Type ARROW Type                                    { TyArrow ($1, $3) }
      | recordType                                         { $1 }
      | LPAREN Type RPAREN                                 { $2 }

recordType: LBRACE fieldTypes RBRACE                       { TyRecord (Map.of_list $2) }

fieldTypes: ID COLON Type moreFieldTypes                   { ($1, $3)::$4 }

moreFieldTypes:                                            { [] }
                | COMMA ID COLON Type moreFieldTypes       { ($2, $4)::$5 }

      
// (), id or id1 id2 ... idN
parameters:   LPAREN RPAREN                                { [] }
            | parameter moreParams                         { $1::$2 }

moreParams:                                                { [] }
            | parameter moreParams                         { $1::$2 }
            
parameter:   ID                                            { (Param (Identifier $1, None)) }
           | LPAREN ID COLON Type RPAREN                   { (Param (Identifier $2, Some $4)) }

// Records: { a = 1, b = ... }

record:   LBRACE expr WITH initList RBRACE                 { RecordWith ($2, $4) }
        | LBRACE initList RBRACE                           { Record $2 }

initList: ID ASSIGN expr moreInits                         { ($1, $3)::$4 }

moreInits:                                                 { [] }
           | COMMA ID ASSIGN expr moreInits                { ($2, $4)::$5 }


// Zero or more, comma-separated expressions
args:                                                      { [] }
      | expr more_args                                     { $1::$2 }

more_args:                                                 { [] }
           | COMMA expr more_args                          { $2::$3 }

timeUnit:   SEC                                            { Sec }
          | MIN                                            { Min }
