%{
open Ast
%}

%start toplevel
%start expr

%token <string> ID
%token <int> INTEGER_LITERAL
%token <bool> BOOLEAN_LITERAL
%token LET IN WITH IF THEN ELSE
%token LPAREN RPAREN LBRACKET RBRACKET LBRACE RBRACE ASSIGN
%token DOT COLON SEMICOLON ARROW PLUS MINUS TIMES DIV MOD COMMA
%token SEMICOLON2
%token GT GTE EQ DIFF LTE LT AND OR TRUE FALSE
%token SEC MIN
%token EOF

%nonassoc LET IN
%right ARROW
%right SEMICOLON
%nonassoc IF THEN ELSE
%left OR
%left AND
%left EQ DIFF
%left GT GTE LTE LT
%left PLUS MINUS
%left TIMES DIV MOD
%left DOT
%nonassoc LPAREN LBRACKET

%type <prog list> toplevel
%type <expr> expr

%%

toplevel:   EOF                                            { [] }
          | defTop                                         { $1 }
          | exprTop                                        { $1 }

defTop:   def EOF                                          { [$1] }
        | def SEMICOLON2 toplevel                          { $1::$3 }

exprTop:   expr EOF                                        { [Expr $1] }
         | expr SEMICOLON2 toplevel                        { (Expr $1)::$3 }

def: ID ASSIGN expr                                        { Def (Identifier $1, $3) }


expr:   expr DOT ID                                        { MemberAccess ($1, Identifier $3) }
      | expr LPAREN args RPAREN                            { match $1 with
                                                             | MemberAccess (obj, memb) -> MethodCall (obj, memb, $3)
                                                             | _ -> FuncCall ($1, $3) }
      | LPAREN expr RPAREN                                 { $2 }
      | expr LBRACKET expr RBRACKET                        { ArrayIndex ($1, $3) }
      | parameters ARROW expr                              { Lambda ($1, $3) }
      | expr SEMICOLON expr                                { Seq ($1, $3) }
      | binaryExpr                                         { $1 }
      | IF expr THEN expr ELSE expr                        { If ($2, $4, $6) }
      | LET ID ASSIGN expr IN expr                         { Let (Identifier $2, $4, $6) }
      | record                                             { $1 }
      | ID                                                 { Id (Identifier $1) }
      | symbol                                             { SymbolExpr $1 }
      | INTEGER_LITERAL timeUnit                           { Time (Integer $1, $2) }
      | INTEGER_LITERAL                                    { Integer $1 }
      | BOOLEAN_LITERAL                                    { Bool $1 }

binaryExpr:   arith                                        { $1 }
            | conditional                                  { $1 }

arith:   expr PLUS  expr                                   { BinaryExpr (Plus, $1, $3) }
       | expr MINUS expr                                   { BinaryExpr (Minus, $1, $3) }
       | expr TIMES expr                                   { BinaryExpr (Times, $1, $3) }
       | expr DIV   expr                                   { BinaryExpr (Div, $1, $3) }
       | expr MOD   expr                                   { BinaryExpr (Mod, $1, $3) }

conditional:   expr GT   expr                              { BinaryExpr (GreaterThan, $1, $3) }
             | expr GTE  expr                              { BinaryExpr (GreaterThanOrEqual, $1, $3) }
             | expr EQ   expr                              { BinaryExpr (Equal, $1, $3) }
             | expr DIFF expr                              { BinaryExpr (NotEqual, $1, $3) }
             | expr LTE  expr                              { BinaryExpr (LessThanOrEqual, $1, $3) }
             | expr LT   expr                              { BinaryExpr (LessThan, $1, $3) }
             | expr AND  expr                              { BinaryExpr (And, $1, $3) }
             | expr OR   expr                              { BinaryExpr (Or, $1, $3) }

symbol: COLON ID                                           { Symbol $2 }

// (), id or id1 id2 ... idN
parameters:   LPAREN RPAREN                                { [] }
            | ID moreParams                                { (Identifier $1)::$2 }

moreParams:                                                { [] }
            | ID moreParams                                { (Identifier $1)::$2 }

// Records: { :a = 1, :b = ... }

record:   LBRACE expr WITH initList RBRACE                 { RecordWith ($2, $4) }
        | LBRACE initList RBRACE                           { Record $2 }

initList: symbol ASSIGN expr moreInits                     { ($1, $3)::$4 }

moreInits:                                                 { [] }
           | COMMA symbol ASSIGN expr moreInits            { ($2, $4)::$5 }


// Zero or more, comma-separated expressions
args:                                                      { [] }
      | expr more_args                                     { $1::$2 }

more_args:                                                 { [] }
           | COMMA expr more_args                          { $2::$3 }

timeUnit:   SEC                                            { Sec }
          | MIN                                            { Min }
