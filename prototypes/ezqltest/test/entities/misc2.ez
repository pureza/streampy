temp_readings = stream (:room_id, :temperature);;
entries = stream(:room_id, :product_id);;

lastTemp = temp_readings.last(:temperature);;

enum State =
  | A of int
  | B of int;;

/*
entity Room =
  createFrom(temp_readings, :room_id)


  member self.foo = A(0)
                  when | ev in temp_readings if ev.temperature > 30 -> B(ev.temperature + lastTemp + self.room_id);;
   //                    | ev in entries -> A(0);;


*/

/*

lastTemp = temp_readings.last(:temperature);;

a = listenN (0, when (temp_readings, fun ev -> fun (v:int) -> ev.temperature + v + lastTemp),
                when (entries, fun ev -> fun (v:int) -> 0));;





*/


a = A(3)
  when | ev in temp_readings -> match a with
                                  | A(v) -> A(v + 1)
                                  | B(v) -> A(ev.temperature)
                                end
       | ev in entries -> B(0);;

when (a.updated(), fun ev -> print (a));;


//when (temp_readings, fun ev -> print (Room.all));;


#! temp_readings
Timestamp, room_id, temperature
2,               1,      25
4,               3,      45  # Out-of-order keys (1, 3, 2 instead of 1, 2, 3)
5,               1,      25  # Retain the previous value
6,               2,      50
7,               3,      30
9,               1,      23

#! entries
Timestamp, room_id, product_id
3,               1,          1
4,               1,          2
6,               2,          2
7,               1,          3
8,               2,          1
9,               3,          2