temp_readings = stream (:room_id, :temperature);;
entries = stream(:room_id, :product_id);;

lastTemp = temp_readings.last(:temperature);;

//def something (t:int) =
//  fun (u:int) -> t * u[2 sec].sum()

// Test:
//  - Functions with several parameters
//  - Currying
//x = let g = fun (a:int) (f:int -> int) -> f(a) in
//    g (1) (fun (x:int) -> lastTemp + x);;



// Test:
//  - Functions that return functions
//  - Closures
//  - Currying
//  - Passing records to functions
/*
x = let g = fun (t:int) -> fun (u:{ a:int }) -> t * (u.a[2 sec].sum()) in
    let u = g (1) in
    u ({ a = lastTemp });;
*/

// Test:
//  - Record fields containing functions
//x = let z = { a = { b = { c = fun (t:int) -> t } } } in
//    (z.a.b.c)(lastTemp);;


// Test:
//  - Record fields containing functions that return functions
x = let z = { a = fun (x:int) -> fun (y:int) -> x + y } in
    z.a(lastTemp)(1);;

// DOESN'T WORK
//x = let z = { a = fun (x:int) -> x, b = fun (x:int) -> x * 2 } in
//    let f = fun (x:int) -> (if lastTemp > 25 then z.a else z.b) in 
//    f(1)(lastTemp);;


when (x.updated(), fun ev -> print (x));;

#! temp_readings
Timestamp, room_id, temperature
2,               1,      25
4,               3,      45  # Out-of-order keys (1, 3, 2 instead of 1, 2, 3)
5,               1,      25  # Retain the previous value
6,               2,      50
7,               3,      30
9,               1,      23

#! entries
Timestamp, room_id, product_id
3,               1,          1
4,               1,          2
6,               2,          2
7,               1,          3
8,               2,          1
9,               3,          2

