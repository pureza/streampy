{
#light

open System
open System.Collections
open EzqlParser
open Lexing

let ids = Map.of_list [("class", CLASS);
                       ("if",    IF);
                       ("then",  THEN);
                       ("else",  ELSE);
                       ("new",   NEW);
                       ("let",   LET);
                       ("in",    IN);
                       ("and",   AND);
                       ("or",    OR)];

let tokenize text =
  if ids.ContainsKey(text)
      then ids.[text]
      else ID text
}

let num        = ['0'-'9']+
let alpha      = ['a'-'z' 'A'-'Z']
let identifier = alpha+ (alpha | ['_'])*
let integer    = '-'? num
let whitespace = ' ' | '\t'
let newline    = '\n'

rule token = parse
    | whitespace { token lexbuf }
    | newline    { (lexbuf:lexbuf).EndPos <- lexbuf.EndPos.NextLine; token lexbuf }
    | "{"        { BEGIN }
    | "}"        { END }
    | "("        { LPAREN }
    | ")"        { RPAREN }
    | "["        { LBRACE }
    | "]"        { RBRACE }
    | "+"        { PLUS }
    | "-"        { MINUS }
    | "*"        { TIMES }
    | ">"        { GT }
    | ">="       { GTE }
    | "="        { EQ }
    | "!="       { DIFF }
    | "<="       { LTE }
    | "<"        { LT }
    | "!"        { NOT }
    | ","        { COMMA }
    | "."        { DOT }
    | ":"        { COLON }
    | "\\"       { LAMBDA }
    | "->"       { ARROW }
    | identifier { tokenize (lexeme lexbuf) }
    | integer    { INTEGER_LITERAL (Int32.Parse(lexeme lexbuf)) }
    | eof        { EOF }



